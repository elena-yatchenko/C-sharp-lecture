// Парсинг входной строки

//Есть строка, в которой находятся парные координаты точек фигуры. 
// Наша задача — увеличить каждую из координат в два раза и показать пользователю ответ

// Можно описать метод, который сначала будет разбивать пары в скобках. Затем, описав отдельный
// метод, взять каждую пару (то есть точку с координатой X и координатой Y), и увеличить значение
// каждой координаты с помощью ещё одного метода. 

using System.Ling;

// string text = "(1,2) (2,3) (4,5) (6,7)"

// var data = text.Split(" ")
//                 .ToArray();

// for (int i = 0; i < data.Length; i++)
// {
//     System.Console.WriteLine(data[i]);
// }
// Итак, у нас была строка, которая содержала в себе сразу все точки. Мы разбили её и получили 4 точки. 

// Пока что это строки. Технически вместо var мы можем прописать массив строк. Чтобы постоянно типы
// не менять, я оставлю var.
// Дальше моя задача — взять пару и на её основе получить точку с числами, а не со строками.
// Технически скобки для нас ничего не значат, поэтому я могу избавиться от них на первом этапе. Для
// этого я напишу метод Replace, где в качестве первого аргумента мы укажем открывающую скобку, а в
// качестве второго — на что её нужно заменить. В данном случае — на пробел. Затем делаем то же с
// закрывающей строкой. На выходе у нас будет строка без скобок. 

// string text = "(1,2) (2,3) (4,5) (6,7)"
//                 .Replace("(", "")
//                 .Replace(")","")
//                 ;
// System.Console.WriteLine(text);

// var data = text.Split(" ")
//                 .ToArray();

// for (int i = 0; i < data.Length; i++)
// {
//     System.Console.WriteLine(data[i]);
// }
//  Что делаем дальше? В каждом элементе можем
// сделать выборку, то есть разбить каждый элемент и получить на его основе массив из двух чисел.
// Первое число будет координатой X, второе — Y. 

// string text = "(1,2) (2,3) (4,5) (6,7)"
//                 .Replace("(", "")
//                 .Replace(")", "")
//                 ;
// System.Console.WriteLine(text);

// var data = text.Split(" ")
//                 .Select(item => item.Split(','))
//                 .ToArray();

// for (int i = 0; i < data.Length; i++)
// {
//     System.Console.WriteLine(data[i]);


//     // Когда выполним эту конструкцию, получим массив массивов. Каждым его элементом будет массив из
//     // 2-х строк. Давайте проверим. 
//     //Сейчас мы наблюдаем просто массив data[i]. Проведу ещё раз внутренний цикл.
//     for (int k = 0; k < data[i].Length; k++)
//     {
//         System.Console.WriteLine(data[i][k]);
//     }
// }
// После того как мы получили массив координат, может сделать ещё одну выборку. Сказать: «Давайте
// мы текущий массив координат превратим в кортеж чисел». При этом мы будем сами делать разбор
// строки (мы помним, что у нас массив строк). Первый элемент массива нулевой, в качестве второго я
// буду передавать int.Parse(e1).

// string text = "(1,2) (2,3) (4,5) (6,7)"
//                 .Replace("(", "")
//                 .Replace(")", "")
//                 ;
// System.Console.WriteLine(text);

// var data = text.Split(" ")
//                 .Select(item => item.Split(','))
//                 .Select(e => (int.Parse(e[0]), int.Parse(e[1])))
//                 .ToArray();

// for (int i = 0; i < data.Length; i++)
// {
//     System.Console.WriteLine(data[i]);
//     System.Console.WriteLine();
// }

// Теперь результатом уже будет не массив массивов, а массив кортежей. Поэтому внутренний цикл нам
// не нужен, и мы возвращаем всё как было. 
// Очищаем экран и запускаем. 

// Круглые скобки остались, но теперь это уже числа. То есть в момент вывода я могу написать
// Console.WriteLine(data[i].Item1), что даёт нам первую координату, и, соответственно, умножить её,
// например, на 10. 
// {
//     System.Console.WriteLine(data[i].Item1*10);
// }
// Обратите внимание: в коде у нас сейчас какой-то Item1. Что это — непонятно. Поэтому мы можем
// сказать, пусть int.Parse(e[0]) будет координатой X, а int.Parse(e[1]) — координатой Y:

string text = "(1,2) (2,3) (4,5) (6,7)"
                .Replace("(", "")
                .Replace(")", "")
                ;
System.Console.WriteLine(text);

var data = text.Split(" ")
                .Select(item => item.Split(','))
                .Select(e => (x: int.Parse(e[0]), y: int.Parse(e[1])))
                .ToArray();

for (int i = 0; i < data.Length; i++)
{
    System.Console.WriteLine(data[i].x*10);
    // Теперь Item1 можно заменить на X:
    System.Console.WriteLine();
}

// Data[i] — конкретная точка массива, х — конкретная координата элемента массива, и мы её умножаем
// на 10. И в консоли наблюдаем то, что должны: 

// Можно ли как-то сделать по-другому? Технически, если нам нужно один раз и навсегда сделать
// увеличение этих координат, мы снова можем сделать выборку и дальше сказать: «У нас есть точка
// (point), и мы хотим превратить её во что-то новое». В данном случае это будет point.x, которая
// умножается на 10. А в качестве второго элемента кортежа будет point.у. То есть мы превращаем нашу
// точку с учётом этих вновь появившихся дополнений. 

var data = text.Split(" ")
                .Select(item => item.Split(','))
                .Select(e => (x: int.Parse(e[0]), y: int.Parse(e[1])))
                .Select(point => (point.x * 10, point.y))
                .ToArray();

// Дальше — больше. Если вам нужно произвести какую-то выборку, прежде чем делать домножение, вы
// можете сказать: «А давайте мы соберём или получим только те точки, для которых первая координата
// делится на 2 (то есть координата чётная). Хочу, чтобы выполнялось такое условие.


var data = text.Split(" ")
                .Select(item => item.Split(','))
                .Where(e => e.x % 2 == 0)
                .Select(e => (x: int.Parse(e[0]), y: int.Parse(e[1])))
                .Select(point => (point.x * 10, point.y))
                .ToArray();


                